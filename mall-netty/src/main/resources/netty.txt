Netty内部的线程模型？

NioEventGroup(Selector+TaskQueue)
每个线程并不是单存的Thread，而是每个Thread封装了一个Selector

command+alt+u

异步事件驱动框架，用于快速开发高性能服务端和客户端。
封装了JDK底层BIO和NIO模型，提供了高度可用的API
自带编码解码器解决拆包粘包问题，用户只需要关心业务逻辑
精心设计的Reactor模型栈。

.handler:是处理服务端逻辑的---channel添加，注册     可以做一些连接日志

.childHandler:是对连接的一些处理,业务处理类


服务端的Socket在哪里初始化的？

默认情况下，Netty服务端启动了几个线程。
Netty是如何解决空轮询Bug问题？
Netty是如何保证异步串行无锁化？


Netty的线程模型？


2018-11-10

Netty的粘包和拆包？
Netty心跳检测机制？


Netty源码解析笔记：

===========================================尚硅谷Netty==============================================
1>Netty是一个异步的，基于事件驱动的网络应用框架，用于快速开发高性能，高可靠性的网络IO程序。
2>Netty主要针对在TCP协议下，面向Clients端的高并发应用。
3>Netty本质是一个NIO框架

I/O模型简单的理解：就是用什么样的通道进行数据的发送和接收

Java BIO：同步并阻塞，服务器实现模式为一个连接一个线程，客户端有连接请求时服务端就需要启动一个线程进行处理。

Java NIO：同步非阻塞，服务器实现模式为一个线程处理多个请求，即客户端发送的连接请求都会注册到多路复用器上，多路复用器
轮询到连接有I/O请求就进行处理。

BIO编程简单流程：
1>服务器启动一个ServerSocket
2>客户端启动Socket对服务器进行通信，默认情况下服务器端需要对每个客户端建立一个线程与之通讯。


通道：
NIO的通道类似于流，但是有些区别如下：
1>通道可以同时进行读写，而流只能读或者只能写
2>通道可以实现异步读写数据
3>通道可以从缓冲读数据，也可以写数据到缓冲


1月26号======8:25开始看
看到P17

MappedByteBuffer：可以让文件直接在内存(堆外内存)中进行修改，操作系统不需要拷贝一次


Java NIO：
1>Java的NIO，用非阻塞的IO方式，可以用一个线程，处理多个客户端连接，就会使用到Selector选择器
2>Selector能够检测多个注册的通道上是否有事件发生(多个channel以事件的方式可以注册到同一个selector上)，如果有事件发生，
便获得事件然后对每个事件进行相应的处理。
3>只有在 连接/通道真正有读写事件发生时，才会进行读写，就大大减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程。
4>避免了多线程之间的上下文切换导致的开销。




1:当客户端有连接时，会通过ServerSocketChannel获得SocketChannel，
2:并将SocketChannel注册到Selector上,一个Selector可以注册多个SocketChannel。
3:注册后会返回一个SelectionKey,会和该Selector进行关联。
4:selector进行监听select方法，返回有事件发生的通道个数。
5:在进一步得到各个SelectionKey(有事件发生)
6:再通过SelectionKey反向获取SocketChannel.channel()
7:可以通过得到的channel完成业务处理。



ServerSocketChannel在服务器端监听新的客户端Socket连接

SocketChannel，网络IO通道，具体负责进行读写操作，NIO把缓冲区的数据写入到通道，或者把通道里的数据读到缓冲区。


零拷贝基本介绍：
1>零拷贝是网络编程的关键，很多性能优化都离不开
2>在Java程序中，常用的零拷贝有mmap(内存映射)和sendFile


mmap通过内存映射，将文件映射到内核缓冲区，同时用户空间可以共享内核空间的数据，这样，在进行网络传输时，就可以减少
内核空间到用户空间的拷贝次数

提示：零拷贝是从操作系统角度，是没有cpu拷贝

mmap和sendFile的区别
1>mmap适合小数据量读写，sendFile适合大文件传输
2>mmap需要4次上下文切换，3次数据拷贝，sendFile需要3次上下文切换，最少2次数据拷贝
3>sendFile可以利用DMA方式，减少CPU拷贝，mmap则不能(必须从内核拷贝到Socket缓冲区)





Future说明
1>表示异步的执行结果，可以通过它提供的方法来检测执行是否完成
2>ChannelFuture是一个接口：可以添加监听器，当监听的事件发生时，就会通知到监听器


Netty本身自带的ObjectEncoder和ObjectDecoder可以用来实现POjO对象或各种业务对象的编码和解码，底层使用的是
Java的序列化技术，而Java的序列化技术本身效率就不高，存在如下问题
无法跨语言
序列化后体积太大，是二进制编码的5倍多
序列化性能太第

引出新的解决方案：ProtoBuf


TCP粘包和拆包解决方案：

自定义协议去解决








